
## 회전초밥 (문제 _ [15961](https://www.acmicpc.net/problem/15961))

회전 초밥 음식점에는 회전하는 벨트 위에 여러 가지 종류의 초밥이 접시에 담겨 놓여 있고, 손님은 이 중에서 자기가 좋아하는 초밥을 골라서 먹는다. 초밥의 종류를 번호로 표현할 때, 다음 그림은 회전 초밥 음식점의 벨트 상태의 예를 보여주고 있다. 벨트 위에는 같은 종류의 초밥이 둘 이상 있을 수 있다.

새로 문을 연 회전 초밥 음식점이 불경기로 영업이 어려워서, 다음과 같이 두 가지 행사를 통해서 매상을 올리고자 한다.

1.  원래 회전 초밥은 손님이 마음대로 초밥을 고르고, 먹은 초밥만큼 식대를 계산하지만, **벨트의 임의의 한 위치부터 k개의 접시를 연속해서 먹을 경우** 할인된 정액 가격으로 제공한다.
2.  각 고객에게 초밥의 종류 하나가 쓰인 쿠폰을 발행하고, 1번 행사에 참가할 경우 **이 쿠폰에 적혀진 종류의 초밥 하나를 추가로 무료로 제공한다**. 만약 이 번호에 적혀진 초밥이 현재 벨트 위에 없을 경우, 요리사가 새로 만들어 손님에게 제공한다.

위 할인 행사에 참여하여 가능한 한 다양한 종류의 초밥을 먹으려고 한다. 위 그림의 예를 가지고 생각해보자. k=4이고, 30번 초밥을 쿠폰으로 받았다고 가정하자. 쿠폰을 고려하지 않으면 4가지 다른 초밥을 먹을 수 있는 경우는 (9, 7, 30, 2), (30, 2, 7, 9), (2, 7, 9, 25) 세 가지 경우가 있는데, 30번 초밥을 추가로 쿠폰으로 먹을 수 있으므로 (2, 7, 9, 25)를 고르면 5가지 종류의 초밥을 먹을 수 있다.

회전 초밥 음식점의 벨트 상태, 메뉴에 있는 초밥의 가짓수, 연속해서 먹는 접시의 개수, 쿠폰 번호가 주어졌을 때, 손님이 먹을 수 있는 초밥 가짓수의 최댓값을 구하는 프로그램을 작성하시오.

**입력**
첫 번째 줄에는 회전 초밥 벨트에 놓인 접시의 수 N, 초밥의 가짓수 d, 연속해서 먹는 접시의 수 k, 쿠폰 번호 c가 각각 하나의 빈 칸을 사이에 두고 주어진다. 단, 2 ≤ N ≤ 3,000,000, 2 ≤ d ≤ 3,000, 2 ≤ k ≤ 3,000 (k ≤ N), 1 ≤ c ≤ d이다. 

두 번째 줄부터 N개의 줄에는 벨트의 한 위치부터 시작하여 회전 방향을 따라갈 때 초밥의 종류를 나타내는 1 이상 d 이하의 정수가 각 줄마다 하나씩 주어진다.

**출력**
주어진 회전 초밥 벨트에서 먹을 수 있는 초밥의 가짓수의 최댓값을 하나의 정수로 출력한다.
  

## 예제

	8 30 4 30
	7
	9
	7
	30
	2
	7
	9
	25
	
	< answer >
	5

 
## 풀이
무조건 k개를 연속해서 먹어야 하기 때문에 처음부터 k개를 연속해서 먹어보고, 한 칸 이동해서 연속해서 먹어보고, 한 칸 또 이동하고 이런식으로 진행하면 된다.

이때 최대로 먹을 수 있는 초밥의 종류를 계산해야 하기 때문에 지금까지 먹은 초밥의 종류와 몇개씩 먹었는지 저장하는 과정이 필요하다.

    selected[] - 해당 종류의 초밥을 먹은 개수
    cnt - 먹은 초밥의 종류

> 예를 들어 1 4 3 4 4 를 연속해서 먹었을 경우
> 
> selected[1] = 1 
>
> selected[2] = 0 
>
> selected[3] = 1 
>
> selected[4] = 3 
>
> cnt =3 

처음부터 k개를 연속해 초밥을 먹으면서 selected와 cnt 값을 지정해 준 다음 한 칸씩 초밥을 빼고 추가하는 과정을 거쳐준다.

0번째 초밥부터 5번째까지 먹었다면, 1번째부터 6번째까지 먹는다고 생각하면 된다.

이때 2,3,4,5의 초밥을 먹는 건 동일하기 때문에 0번째 초밥을 selected와 cnt에서 빼주고 6번째 초밥을 추가해 주면 된다.

이런식으로 n번째 초밥부터 k번 연속해서 먹는 경우까지 반복해주고 최대로 먹을 수 있는 초밥의 종류의 개수를 출력한다

## 코드
```java
	// 처음부터 k개까지 연속으로 먹음
	selected[sushi[0]] = 1;
	int cnt = 1; // 초밥 종류
	int end = 0; // 마지막으로 먹은 초밥 인덱스 저장하기 위한 변수
	
	for (int next = 1, tmp = 1; tmp < k; next++, tmp++) {
		if (next == n) next = 0; // 다시 처음으로 돌아감
		if (selected[sushi[next]++] == 0) // 처음으로 먹는 초밥이라면
			cnt++;
		end = next; // 마지막 인덱스 저장
	}
	// 서비스 초밥 먹기
	if(selected[c]++ == 0) cnt++;	
	ans = cnt; // 현재까지 먹은 초밥 개수

	for (int i = 1; i < n; i++) {
		if(--selected[sushi[i-1]]==0) cnt--; // i-1번째 초밥은 먹지 않음
		if(++end == n) end= 0; // 회전초밥 순환
		if(selected[sushi[end]]++ == 0) { // 처음 먹는 초밥이라면
			cnt++;
		}
		if(cnt > ans) ans = cnt; // 초밥 종류 개수 저장
	}
```